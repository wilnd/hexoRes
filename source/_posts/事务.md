---
title: 事务
date: 2018-12-04 11:00:50
tags: java 事务
categories: java
---
事务级别的设置,是对当前事务而言, 
- 当前设置事务级别是读未提交,其他事务就可以读到当前事务未提交的数据
- 当前设置事务级别是读已提交,其他事务过程中,能读到该事务开始前和已提交的数据.
- 当前事务设置的是可重复,这个事务进行更新操作的是后,其他事务不能进行
- 当前事务设置的是序列化,这个事务进行的时候,其他任何事务都不能操作

mysql默认事务级别是可重复读(REPEATABLE-READ),是可以设置的
```
1.查看当前会话隔离级别
select @@tx_isolation;
2.查看系统当前隔离级别
select @@global.tx_isolation;
3.设置当前会话隔离级别
set session transaction isolatin level repeatable read;
4.设置系统当前隔离级别
set global transaction isolation level repeatable read;
```

##### 事务隔离级别
![事务隔离级别](29F59723D30542ABAA7D9C570EA32209)
-  Read Uncommitted 脏读
```
一个事务可以读取另一个未提交事务的数据
假设有一个事务它包含:操作一更新,操作二插入 假设更新操作改变A表的A值由2变为20,插入操作在B表插入一条数据.
有可能出现一种情况,改变A表A值是成功的,插入B表数据是失败,操作二失败,事务会发生回滚.操作一根操作二之间有一个时间间隔,
在这个间隔中,查询A表A的数据看到的值是20,但实际上应该是2,这个叫做脏读
```
-  Read Committed 避免脏读引入重复读==事务隔离级别为读提交时，写数据只会锁住相应的行==
```
 一个事务等另一个事务提交后才能读取数据
有两个事务A,B对同时对同一账号发起扣款,B事务执行得更快.假设账户余额有100块,A事务试图扣80块,B事务试图扣70块.A事务扣款前先查询余额是满足扣款所需的
但实际扣款的时候发现,账号余额不足.查询余额时发现账户余额只剩下30块.A事务发生扣款的时候B事务已经把款扣完了.同一事务范围内两个相同的查询返回了不同的数据,这叫不可重复读
```
-  Repeatable Read 避免重复读引入幻读事务隔离级别为可重复读时，==如果检索条件有索引（包括主键索引）的时候，默认加锁方式是next-key 锁；如果检索条件没有索引，更新数据时会锁住整张表。一个间隙被事务加了锁，其他事务是不能在这个间隙插入记录的，这样可以防止幻读。==
```
update事务串行执行 事务开启,不允许其他事务的update操作,但是不限制insert操作
有两个事务A,B. A先发起,B执行的更快. 谁先执行完另一方没法执行. 在read committed的事务级别下,B会先执行完,A失败.在Repeatable Read 的事务级别下B要等A执行完.
```
- Serializable==事务隔离级别为串行化时，读写数据都会锁住整张表==
```
避免脏,重,幻 	所有事务串行执行 效率很低
```
##### 事务执行的基本元素ACID
- 原子性
```
整个事务的操作,要么全部完成,要么全部不完成
```
- 一致性
```
事务必须保证系统处于一致性状态,例如五个账号里的钱不管如何转账,总额不变
```
- 隔离性
```
同一时间系统中只有一个事务在运行
```
- 持久性
```
事务完成后,该事务对系统所有更改操作,都持久到数据库中
```