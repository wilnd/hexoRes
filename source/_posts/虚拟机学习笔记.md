---
title: 虚拟机学习笔记
date: 2018-08-26 10:09:03
tags: java 虚拟机
categories: java
---

```

A 类加载时机:
1. 生命周期: 加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载
加载:
1.1) 通过一个类的全限定名获取定义此类的二进制字节流
1.2) 将这个字节流所代表的静态存储结构转化为方法区的运行时数据接口
1.3) 在内存中生成一个代表这个类的对象,作为方法区这个类的各种数据访问入口
1.4) 加载未完成,连接可能就已经开始了
验证: Halting Problem : 通过程序校验程序逻辑,无法做到绝对准确
1.1) 连接第一步,确保Class字节流包含的信息符合当前虚拟机的要求.这个阶段是否严谨,决定了java虚拟机能否承受恶意代码的攻击
1.2) 文件格式验证 验证字节流是否符合Class文件格式规范.
	1.2.1 是否以魔数0xCAFEBABE开头
	1.2.2 主次版号是否在当前虚拟机处理范围内
	1.2.3 常量池的常量是否有不被支持的常量类型 ...
1.3) 元数据验证 对字节码描述信息进行语义分析,保证其描述信息符合java语言规范
	1.3.1 这个类是否有父类(除了Object之外,所有类都应该有父类)
	1.3.2 这个类的父类是否集成了不允许被集成的嘞(被final修饰)
	1.3.3 如果这个类不是抽象的,是否实现了其父类或接口要求实现的方法
	1.3.4 类的字段或方法是否与父类产生矛盾(例如:覆盖父类的final字段,出现不符合规则的方法重载)
1.4 字节码验证  对类的方法体进行校验分析,确保被校验嘞的方法在运行时不会做出危害虚拟机的安全事件
	1.4.1 保证任意时刻操作栈的数据类型和指令代码序列都能配合工作
	1.4.2 保证跳转指令不会跳转到方法体外的字节码指令上
	1.4.3 保证方法体中的类型转换是有效的 例如可以把子类对象赋值给父类类型,却不能吧父类对象赋值给子类类型
1.5 符号引用验证 虚拟机将符号引用转换为直接引用 在解析阶段中发生
	1.5.1 通过字符串描述的全限定名是否能找到对应的类
	1.5.2 指定类中是否存在符合方法的字段描述以及简单名称所描述的方法,字段
准备: 正式为类变量分配内存并设置类变量的初始值
	1.1 为静态变量分配内存,并初始化,初始值为0或""或false;
解析: 虚拟机将常量池的符号替换为直接引用
	1.1 类或接口的解析
	1.2 字段解析
	1.3 接口方法解析
初始化: 初始化过程是执行类构造器<clilit>()方法的过程
	<clilit>()方式是有编译器自动收集类中,所有类变量的赋值动作,和静态语句块的语句合并产生,编译器收集的顺序,由语句在源文件中出现的顺序决定.静态语句块只能访问到定义在静态语句块之前的变量,定义在之后的变量在前面的静态语句块中可以赋值,但不能访问.
	1.1 虚拟机在子类的<clinit>()方法执行之前,父类的<clinit>()方法已经执行完毕
	1.2 父类的<clinit>()方法先执行,意味着父类中定义的静态语句块,要优先于子类的变量赋值操作
	1.3 <clinit>()方法非必须,如果一个类中没有静态语句块,也没有变量的赋值操作,编译器可以不为这个类生产<clinit>()方法
	1.4 接口中不能有静态语句块,但仍然有变量初始化的赋值操作,因此接口与类一样会生成<clinit>()方法.但接口与类不同的是执行接口的初始化方法,不需要先执行父接口的初始化方法,只有当父接口中定义的 变量使用时才会初始化
	1.5 虚拟机会保证一个类的<clinit>()方法在多线程的环境中被正确的加锁,同步,如果多个线程去初始化一个类,只会有一个线程去执行<clinit>()方法,其他线程都要阻塞,等待.

类加载器: 把类加载动作放到java虚拟机外部去执行以便让应用程序自己决定如何去获取所需要的类,谁先这个动作的代码叫类加载器. : 通过与一个类的全限定名,来获取描述此类的二进制字节流
	1.1 主要用于OSGI,热部署,代码加密
	1.2 比较两个类是否相等,只有在同一个类加载器加载的前提下才有意义,否则,即使两个类来源于同一个class文件,被同一个虚拟机加载,只要加载他们的类加载不一致,两个类必定不相同
	1.3 启动类加载器,扩展类加载器,应用程序类加载器

B 内存模型与线程
物理机的并发处理方案
	1.1 高速缓存 将运算需要使用到的数据复制到缓存中,让运算能快速进行,运算结束后,然缓存同步到内存中;引入缓存一致性问题
		1.1.2 在多处理器系统中,每个处理器有自己的高速缓存,他们共享同一主内存,当多个处理器运算任务都涉及同一主存时,可能导致各自的缓存数据不一致.为了解决这个一致性问题,需要各个处理器访问缓存时遵循一个协议.
		1.1.3 内存模型:在特定的操作协议下,对特定内存或高速缓存进行读写访问的过程抽象
	1.2 指令重排 对输入代码进行乱序执行,在计算后将乱序执行的结果重组,保证结果跟顺序执行的结果一致,但不保证各语句的时机执行顺序跟代码顺序一致
java内存模型
	主要是定义程序中各个变量的访问规则,即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节
	包括:实例字段,静态字段,构成数组对象的元素 不包括:局部变量和方法参数,它们是线程私有的,不会被共享,不会存在竞争问题.
	1.1 java内存模型规定:
		1.1.1 所有变量都存储在主内存中(类似物理硬件的主内存,不过这里的主内存是java虚拟机的一部分)
		1.1.2 每条线程有自己的工作内存(类似处理器高速缓存),线程的工作内存保存了该线程使用到的变量的主内存副本拷贝,线程对变量的所有操作都必须在工作内存中进行,而不能直接读写主内存变量,不同线程不能访问对方工作内存的变量,线程中变量的值传递需要通过主内存完成.
		1.1.3 主内存主要是对应java堆中对象实例数据部分,工作内存对应虚拟机栈的部分区域(优先存储于寄存器和高速缓存中,工作内存速度会更快)
	1.2内存中交互操作
		1.2.1 关于内存之间的具体交互协议:一个变量如何从主内存拷贝到工作内存,如何从工作内存同步回主内存的实现细节,java中定义了八种操作,这把种操作是原子的.
		1.2.2 lock 锁定:作用于主内存的变量,把一个变量标识为一个线程独占.
		1.2.3 unlock 解锁: 作用于主内存的变量,它把一个处于锁定状态的变量释放出来,释放后才可被其他线程锁定
		1.2.4 read 读取 : 作用于主内存的变量,它把一个变量的值从主内存传输到线程的工作内存中,以便随后的load动作.
		1.2.5 load 加载 : 作用于工作内存变量,它把read操作从主内存得到的变量值放入工作内存的副本中
		1.2.6 use 使用 : 作用于工作内存的变量,它把工作内存中一个变量的值传递给执行引擎,每当虚拟机遇到一个需要使用到变量的值的字节码指令时,将会执行这个操作
		1.2.7 assign 赋值 : 作用于工作内存的变量,它把一个执行引擎接收到的值,赋值给工作内存的变量,每当虚拟机遇到一个给变量赋值的字节码,时会执行这个操作
		1.2.8 store 存储 : 作用于工作内存的变量,它把工作内存的值传递给主内存中,以便随后的write操作的进行
		1.2.9 write 写入: 作用于主内存变量 把store操作从工作内存中得到的变量放入主内存的变量中
		1.2.10 read load操作  store write操作顺序执行,无须连续执行
		1.2.11 不允许read load ,store write操作单独出现
		1.2.12 不允许在工作内存中使用一个未被初始化(load,assign)的变量
		1.2.13 一个变量在同一时刻只能被一个线程lock操作,但lock动作可以被同一线程重复执行多次,多次执行lock后只有执行相同次数的unlock变量才会被解锁
		1.2.14 如果堆一个变量lock操作,会清空工作内存中这个变量的值,在执行引擎使用这个变量前需要重新load或assig
		1.2.15 如果没有执行lock操作,也不能执行unlock操作.在执行unlock操作前,必须把此变量同步到主内存中.
	1.3 volatile型变量的特殊规则
		1.3.1 volatile修饰的变量对所有线程可见,当一条线程改变了这个值,其他线程来说事立即可见的.
		1.3.2 volatile变量存在在各线程中不一样的情况,但是每次使用前都要刷新,执行引擎看不到不一样的情况
		1.3.3 volatile变量不是线程安全的,使用前虽然volatile会同步一次值,但是valitile的计算操作不是原子的,当最后变更这个值的时候volatile使用的值可能是过期的值了.
		1.3.4 使用volatile的场景 状态标记,双重检查
			1.3.4.1 运算结果并不依赖当前值,或者能确保只有单一线程修改变量的值
			1.3.4.2 变量不需要与其他状态变量共同参与不变约束	
		1.3.5 volatile可以避免指令重排的情况
			1.3.5.1 new 一个对象要做四件事: 1. 分配对象内存空间 2.将内存空间的地址赋值给引用 3.在内存空间内初始化对象 4. 初次访问对象. 因为2,3动作不会相互依赖可能会发生指令重排,如果在发生指令重排的时候发生了4动作,会报错.
		1.3.6 valatile如何保证它的特性的
			1.3.6.1 线程对于volotile变量的操作 A操作 read-load-use B操作 assign-store-write 是连续的,所以在使用volotil变量的时候,一定会先从主内存read-load-use获取,变更后会直接刷到主内存
			1.3.6.2 如果对于第一个valotile变量的A操作在前,对第二个变量的A操作在后,那么对第一个变量的B操作也会在前
	1.4 long和double的非原子性协定: 他们的load store read write操作可以不保证原子性,对double long的操作会出现"半个变量"的数值
	1.5 原子性,可见性,有序性
		1.5.1 原子性
			1.5.1.1 由java内存模型直接保证原子性变量的操作包括:read load use assign store write
			1.5.1.2 由lock和unlock保证更大范围的原子性,他们所指代的更高层次的字节码:monitorenter,monitorout,也就是java代码的synchronized
		1.5.2 可见性
			1.5.2.1 一个线程修改了共享变量的值,其他线程能够立即得知这个值,无论普通变量还是volatile变量都是如此.volatile的特殊在于,新值能立即同步到主内存,以及每次使用前从主内存刷值
			1.5.2.2 synchronized的可见性在于,对于一个变量执行unlock操作前,必须把此变量同步到主内存.
			1.5.2.3 final的可见性在于,final一旦被初始化完成,并不会把this的引用传递出去,
		1.5.3 有序性
			1.5.3.1 如果在本内存内观察,所有操作都是有序的 "线程内表现为串行"
			1.5.3.2 如果在一个线程中观察另一个线程,所有操作都是无序的. "指令重排"
			1.5.3.3 通过volatile和synchronized两个关键字来保证有序性,
		1.5.3 先行发生原则
			1.5.3.1 所谓A先于B发生,就是指操作B之前,操作A,能被B观察到,这样是线程安全的,
			java内存模型规定的先行发生关系:
			程序次序规则:	一个线程内,按照程序代码顺序,书写在前面的操作先于书写在后面的操作
			管程锁定规则:	一个unlock操作先于同一个锁的lock操作
			volatile变量规则: 一个volatile的写操作,先于后面发生的读操作
			线程启动规则:	thread的start方法先于这个线程的每一个动作
			线程中止规则:	线程中所有操作都先行发生于线程的中止检测
			线程中断规则:	中断时间的发生先行发生于中断时间的检测
			对象终结规则:	一个对象的初始化完成,先于发生它的finalize方法的开始
			传递性:			A先行发生于B,B先行发生于C 则A先行发生于C
	
java与线程
	1使用内核线程
		1.1 直接由操作系统内核支持的线程.程序一般不会直接使用内核线程,而是去使用内核线程的一种高级接口-轻量级进程,每个轻量级进程都由一个内核线程支持.
		1.2 系统的轻量级进程,需要系统调用,系统调用的代价较高,一个系统支持轻量级进程数量是有限的
	2.使用用户线程
		2.1 用户线程的建立,同步,销毁,调度完全在用户态中进行,不需要内核帮助,因此快速,低消耗.也可以支持规模更大的线程数量.
		2.2 但是因为没有系统内核支援,线程的创建,调度,协调都需要用户自己考虑,java已放弃.
	3. 用户线程和轻量级进程混合
java线程调度
	系统为线程分配处理器使用权的过程,
	1. 协同式线程调度
		1.1 线程的执行时间由线程本身控制,线程把自己的工作执行完了后,主动通知系统切换到另一个线程上
		1.2 切换操作对线程是可知的,所以没有线程同步的问题
	2. 抢占式线程调度
		2.1 每个线程由系统来分配执行时间,线程的切换不由自己控制,可以主动让出线程(Thread.yield()),要获取执行时间,线程本身是没有什么办法.
		2.2 虽然java的线程调度是由系统决定的,但是可以建议系统给某些线程多一些执行时间,通过设置线程优先级决定.	
状态转换
	1. new 新建 创建尚未启动的线程
	2. runnable 运行 running和ready状态的线程都有可能正在执行
	3. waiting 无限期等待	不会分配cpu时间,登台其他线程显示唤醒
		3.1 没有设置TimeOut参数的Object.wait()方法
		3.2 没有设置TimeOut参数的Thread.join()方法
		3.3 LockSupport.park()方法
	4. time waiting 限期等待 不会分配CPU时间,无需等待其他线程显示唤醒,一定时间后会自动唤醒
		4.1 Thread.sleep()
		4.2 设置timeout参数的Object.wait()方法先执行		
		4.3 设置timeout参数的Thread.join()方法
		4.4 LockSupport.parkNanos()
		4.5 LockSupport.parkUntil()方法
	5. block 阻塞	线程被阻塞了,等待另外一个线程放弃这个锁
	6. terminated 结束
	
			
C 线程安全与锁优化
	1. 线程安全
		1.1 代码本身封装了所有必要的正确性保障手段,令调用者无需关注多线程的问题,更无须自己采取任何措施来保证多线程的正确调用
	2. Java中的各种操作共享数据
		2.1 不可变
			2.1.1 不可变的变量/对象一定是线程安全的	final修饰的成员变量/final修饰对象的所有变量,对象不可变
		2.2 绝对线程安全
			2.2.1 不管运行环境如何,调用者都不需要任何同步措施,达到这一点很难
		2.3 相对线程安全
			2.3.1 就是我们讲的线程安全,他需要保证对这个对象的操作是线程安全的,我们在调用的时候不需要做额外的保护措施
			2.3.2 对于一些特定顺序的额外调用,我们可能需要在调用端使用额外的调用手段保证调用的正确性.java中大多数线程安全类都属于这个类型:Vector,HashTable,Collections
		2.4 线程兼容
			2.4.1 线程兼容是指对象本身不是线程安全的,但在调用的时候使用正确的手段保证对象在并发情况下可安全使用,我们常说的一个类不安全,大多指这种情况.例如ArrayList,HashMap
		2.5 线程对立
			2.5.1 线程对立是指,无论调用方是否采取同步措施,都无法在多线程下安全使用的代码
			2.5.2 例如Thread的suspend()和resume(),如果两个线程同时持有一个线程对象,一个尝试去中断,另外一个去尝试恢复,如果并发执行的话,无论是否进行同步,都有死锁风险.
	3. 线程安全的实现方法
		3.1 互斥同步.保证共享数据在同一时刻只被一个或者一些线程使用.例如:synchronized,reentrantLock
		3.2 非阻塞式同步. 
			3.2.1 互斥同步带来的问题是线程的阻塞和唤醒带来的性能问题,因此互斥同步也称为阻塞式同步.
			3.2.2 基于冲突检测的乐观并发策略:先进行操作,如果没有其他线程争用共享数据,那操作就成功了.如果共享数据有争用,产生冲突就采取其他补偿措施(不断重试,直到成功为止).用AtomicIUInteger代替int
		3.3无同步方案
			3.3.1 有一些代码本身就不涉及共享数据
			3.3.2 可重入代码
				3.3.2.1 不依赖存储堆上的数据和公用的系统资源
				3.3.2.2 用到的状态都是由参数传入,不调用非可重入的方法等.
			3.3.3 线程本地存储
				3.3.3.1 如果一段代码中的数据必须与其他代码共享,但能保证共享数据在某个线程内执行.
				3.3.3.2 实例:使用消费-队列的架构模式的系统,最经典的是web的交互一个请求对应一个服务器线程.

	4. 锁优化
		4.1 自旋锁和自适应自旋
			4.1.1 如果物理机上有一个以上的处理器,能让两个或以上的线程同时并行执行,可以让后面的线程稍等一下[不放弃处理器的执行时间],看持有锁的线程是否很快释放锁.,为了让线程等待,我们只需让线程执行一个忙循环(自旋)
			4.1.2 自旋锁避免了线程切换的开销,但是占用处理器的执行时间
			4.1.3 自适应自旋锁
		4.2 锁销除
			4.2.1 虚拟机即时编译器在运行时,对一些代码上要求同步,但被检测到不可能存在共享数据竞争的锁进行销除.
		4.3 锁粗化
			4.3.1 如果虚拟机探测到有一串零碎的操作都对同一个对象进行操作,将会把加锁同步的方位扩展到整个操作序列外部.
		4.4 轻量级锁
			4.4.1 
		4.5 偏向锁

D 内存区域与内存溢出
程序计数器 : 线程私有 是一块较小的工作空间,可以看做是当前线程所执行的字节码的行号指示器
	1.1 字节码解释器在执行时就是通过改变程序计数器的值选取下一条需要执行的字节码指令:分支,循环,跳转,异常处理,线程恢复等基础功能都需要依赖这个计数器来完成
	1.2 java虚拟机的多线程是通过线程的轮流切换,并分配处理器执行时间的方式来实现,在任何一个确定的时刻,一个处理器(对于多核来说事一个内核)都会执行一条线程中的执行指令,因此为了线程切换回来后回复到正常的执行位置,每条线程需要有个独立的程序计数器
	1.3 如果线程执行到一个java方法,这个计数器指向的是正在执行的虚拟机字节码指令地址;如果执行的是native方法,这个计数器则为空,唯一一个java虚拟机规范中没有OutOfMemoryError情况的区域
java虚拟机栈 : 线程私有 描述java方法执行的内存模型:每个方法在执行同时都会创建一个栈帧,用语存储局部变量表,操作数栈,动态链接,方法出口等信息.每个方法从调用直至完成的过程,就对应一个栈帧在虚拟机中入栈到出栈的过程
本地方法栈: 线程私有 与虚拟机栈发挥的作用非常相似.虚拟机栈是虚拟机执行java方法的服务,本地方法栈为虚拟机使用native方法服务.
java堆: 各线程共享 堆是java虚拟机中内存最大的一块,此区域唯一存在的目的就是存放对象实例.
	1.1 java堆是垃圾收集器管理的主要区域,因此很多时候被称为GC堆,
	1.2 java堆可以是物理上不连续的内存空间,只要逻辑上是连续的即可,通过(-Xms和-Xmx控制)
方法区: 各线程共享
	1.1 存储编译后的数据包括:类信息,常量,静态变量.
	1.2 这个区域的回收目标,主要针对常量池的回收,以及类的卸载.尤其是类型的卸载条件相当苛刻,
运行时常量池:
	1.1 用于存放编译器生成的各种字面量和符号引用
	1.2 直接内存,介于java堆与native堆之间
	
new 一个对象发生的事情:
	1.1 检查这个指令的参数是否能在常量池中定位到一个类的符号引用,检查这个符号引用所代表的类是否已被加载,解析,初始化,如果没有,必须执行相应的类加载过程
	1.2 虚拟机为新生对象分配内存,对象所需内存大小在类加载完成后便可完全确认,内存分配的方式有两种,:
		1.2.1 指针碰撞 如果堆内存是规整的,所有用过的内存放在一边,空闲的内存放在另一边,中间放着一个指针作为分界点的指示器
		1.2.2 空闲列表 如果堆内存是不规整的,已使用的内存与空闲内存相互交错.虚拟机必须维护一个列表,记录哪些内存是可用的,在分配时,找一个足够大的空间分配给对象实例,并更新列表上的记录
		1.2.3 选择哪种由java堆是否规整决定,java堆是否规整又由采用的垃圾收集器是否带有压缩整理功能决定
		1.2.4 并发情况下对象内存的分配有两种方式
			1.2.4.1 对分配内存空间动作做同步处理 虚拟机通过CAS+失败重试的方式保证更新操作原子性
			1.2.4.2 分配动作按照线程划分在不同的空间之中进行,每个线程再java堆中预先分配已小块内存(Thread Local Allocation Buffer,TLAB),哪个线程要分配内存就在哪个线程的TLAB上分配,只有在TLAB用完,并分配新的TLAB时才同步锁定
	1.3 内存分配完成后,对对象进行表要的设置:这个对象是哪个类的实例,如何才能找到类的元数据信息,对象的哈希码,对象的GC分代年龄,这些信息放在对象的对象头中.
	1.4 执行对象的<init>方法,将对象按照程序员的意向进行初始化
	
对象的内存布局:
	1.1 对象头		
		1.1.1 存储对象自身运行时数据(Mark Word):哈希码,GC分代年龄,锁状态标识,线程持有的锁,偏向线程ID,偏向时间戳,
		1.1.2 类型指针 对象指向他的类元数据的指针
	1.2 实例数据
		1.2.1 对象真正存储的有效信息,无论是从父类继承下来的,还是子类中定义的,都需要记录下来.
	1.3 对齐填充
		不是必然存在,也没有特殊含义,起占位符的作用.保证对象的大小是8字节数的证书倍
		
对象的访问定位:
	1.1 java程序主要是通过栈上的reference来访问操作堆上的具体对象,对象的访问方式取决于虚拟机的实现而定,目前主流的访问方式有使用句柄和直接指针两种方式
	1.2 如果使用句柄,java堆会划分一块内存来作为句柄池,reference存储的是句柄的地址.句柄包含对象实例数据的指针,与对象类型数据的指针
	1.3 如果使用直接指针,reference存储的是对象的直接地址.对象实例数据中存储的是对象类型数据的指针(常用)
	
OutOfMemoryError异常:
	除了程序计数器,虚拟机内存的其他几个运行时区域都有发生OOM的可能
	1.1 根据异常信息,快速判定哪个区域的内存溢出;知道什么样的代码会导致这些区域内存溢出;以及出现这些异常后要怎么处理;
	1.2 java堆溢出 只要不断创建对象,并且保证 GC Roots到达对象之间有可达路径来避免垃圾回收机制清除这些对象,那么对象达到最大对容量后就会产生内存溢出.
	1.3 内存泄漏 有不可被垃圾回收的对象;内存溢出 分配的内存空间不够
	1.4 对于堆内存溢出,可以适当的调整虚拟机堆参数(-Xms和-Xmx)
	1.5 虚拟机栈和本地方法栈溢出
		1.5.1 如果线程请求的栈深度大于虚拟机所允许的最大深度,抛出StackOverFlowError
		1.5.2 如果虚拟机在扩展栈时无法得到足够的内存空间,抛出OutOfMemoryError
		1.5.3 使用-xss参数配置虚拟机栈的大小
	1.6 方法区和运行时常量池溢出	通过 -XX:permsize 和-XX:maxpermsize限制方法区大小
	
		
E 垃圾收集器内存分配策略
	1. 对象已死吗
		1.1 引用计数算法
			1.1.1 给对象中添加一个引用计数器,每当有一个地方引用它时,计数器值+1,当引用失效时,计数器值减一,当对象为0时,对象不可能再被使用.
		1.2 可达性分析算法
			1.2.1 以GC ROOT对象作为起始点,从这些子节点开始向下搜索,搜索到的路径称为引用链,当一个对象到GC ROOT没有任何引用链相连时,证明此对象是不可用的.
		1.3 一般来说回收堆的效果比回收方法区的效果要好,回收堆中的新生代比回收堆中的永久带效果要好
	2. 垃圾收集算法
		2.1 标记清除算法
			2.1.1 标记 标记需要回收的对象
			2.1.2 清除 标记完后统一回收被标记的对象
			2.1.3 标记和清除两个过程的效率都不高;标记清除后会产生大量不连续的内存碎片,内存碎片太多会导致分配大对象时找不到足够的连续空间触发另一轮垃圾收集.
		2.2 复制算法
			2.2.1 将可用内存划分为容量相等的两块,每次只使用其中的一块,当一块用完后,还存货的对象放到另一块上,再把已使用过的内存空间一次性清理.
			2.2.2 简单高效,但是将内存缩小为原先的一半
		2.3 标记整理算法
			2.3.1 标记过程跟标记清除算法一样,但后续步骤不是直接对可回收对象进行清理,而是让存货对象都想一段移动,直接清理掉端边界外的内存.
		2.4 分代收集算法
			2.4.1 根据对象存活周期化为为几块,根据各个年代的特点,采用适当的手机算法.
	3. 内存的分配和回收策略
		3.1 对象优先在Eden分配
			3.1.1 大多数情况下,对象在新生代Eden区中分配,当Eden区没有足够的空间进行分配时,虚拟机会发起一次Minor GC
			3.1.2 大对象直接进入老年代 .例如很长的字符串,以及数组.
			3.1.3 长期存活的对象将进入老年代
			3.1.3 空间分配担保
		
F 虚拟机性能监控以及故障处理(选修)
		



	
```
